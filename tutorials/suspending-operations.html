<div class="static-content">

  <div class="index-list">

    <ul>
      <li><a href="#page-suspend-feature">Suspend rendering feature</a></li>
      <li><a href="#page-suspend-api">API methods</a></li>
      <li><a href="#page-suspend-demo">Supsend - an example</a></li>
    </ul>
  </div>

  <div class="example-container head-gap clearfix" name="suspend-feature">
    <h3 id="page-suspend-feature">Suspend rendering feature</h3>
    <p>Suspend/batch operation might be useful if you want to improve the performance.
      Batching several costly operations can decrease the number of reflows and render cycles for CRUD operations.
      It results in less layout trashing, fewer freezes, and a more responsive feel.

      There are several API methods that allows supsending:
      - suspendRender and resumeRender pair
      - batchRender
      - suspendExecution and resumeExecution pair
      - batchExecution
      - batch

      Please note that this is an advanced feature which can improve the performance but should be used with caution.
      Misuse can result in some flickering, glitches, or other visual distortion.
    </p>

  <div class="example-container head-gap clearfix" name="suspend-api">
    <h3 id="page-suspend-api">Suspend API methods</h3>
    <p>Suspend rendering</p>

    <p>
      <p>suspendRender and resumeRender</p>
      To suspend the rendering process you can use suspendRender method just before the actions you want to postpone.
      There is a small drawback to this manual approach - you need to remember to actually resume the process
      with the resumeRender method.
      <pre>
        <code class="lang-js">
          hot.suspendRender(); // suspend rendering
          hot.alter('insert_row', 5, 45);
          hot.setDataAtCell(1, 1, 'x');
          hot.resumeRender(); // remember to resume rendering
        </code>
      </pre>

      <p>batchRender </p>
      Batching the render is less prone to human errors. You don't have to remember about resuming the operations.
      The drawback is - it doesn't support async operations.
      <pre>
        <code class="lang-js">
          hot.batchRender(() => {
            hot.alter('insert_row', 5, 45);
            hot.setDataAtCell(1, 1, 'x');
            // The table will be rendered once after executing the callback
          });
        </code>
      </pre>
    </p>

    <p>Suspend execution</p>

    <p>
      <p>suspendExecution and resumeExecution</p>
      Note: Term "execution" refer refers to all operations different than DOM rendering. urrently, only the indexes recalculation allows to postpone the process.
      To suspend the execution you can use suspendRender method just before the actions you want to postpone.
      There is a small drawback to this manual approach - you need to remember to actually resume the process
      with the resumeRender method.
      <pre>
        <code class="lang-js">
          hot.suspendExecution();
          const filters = hot.getPlugin('filters');

          filters.addCondition(2, 'contains', ['3']);
          filters.filter();
          hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });
          hot.resumeExecution(); // It updates the cache internally
        </code>
      </pre>

      <p>batchExecution </p>
      Batching the execution is less prone to human errors. You don't have to remember about resuming the operations.
      The drawback is - it doesn't support async operations.
      <pre>
        <code class="lang-js">
          hot.batchExecution(() => {
            const filters = hot.getPlugin('filters');

            filters.addCondition(2, 'contains', ['3']);
            filters.filter();
            hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });
            // The table cache will be recalculated once after executing the callback
          });
        </code>
      </pre>
    </p>

    <p>Batch render and execution</p>

    <p>
      <pre>
        <code class="lang-js">
          hot.batch(() => {
            hot.alter('insert_row', 5, 45);
            hot.setDataAtCell(1, 1, 'x');

            const filters = hot.getPlugin('filters');

            filters.addCondition(2, 'contains', ['3']);
            filters.filter();
            hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });
            // The table cache will be recalculated and table render will be called once after executing the callback
          });
        </code>
      </pre>

    </p>

  <div class="example-container clearfix" name="suspend-demo">
    <h3 id="page-suspend-demo">Preview of built-in and custom cell types</h3>
    <p>Suspend demo</p>
      <div data-jsfiddle="example1">
        <div id="example1" class="hot"></div>
      </div>

      <div class="codeLayout">
        <div class="buttons">
          <button class="jsFiddleLink" data-runfiddle="example1">
            <i class="fa fa-jsfiddle"></i>
            Edit
          </button>
          <button class="dump" name="dump" data-dump="#example1" data-instance="hot1"
                  title="Print current data source to console">
            <i class="fa fa-terminal"></i>
            Log to console
          </button>
        </div>
        <script data-jsfiddle="example1">
          var
            data = [
              ['', 'Tesla', 'Nissan', 'Toyota', 'Honda', 'Mazda', 'Ford'],
              ['2017', 10, 11, 12, 13, 15, 16],
              ['2018', 10, 11, 12, 13, 15, 16],
              ['2019', 10, 11, 12, 13, 15, 16],
              ['2020', 10, 11, 12, 13, 15, 16],
              ['2021', 10, 11, 12, 13, 15, 16]
            ],
            container1 = document.getElementById('example1'),
            hot1;

          hot1 = new Handsontable(container1, {
            data: data,
            startRows: 5,
            startCols: 5,
            colHeaders: true,
            minSpareRows: 1
          });</script>
      </div>
  </div>

  <p class="gap-top-xsmall">
    <a href="https://github.com/handsontable/docs/edit/<?js= version ?>/tutorials/cell-types.html" class="edit-doc" target="_blank">
      Edit this page
    </a>
  </p>
</div>
